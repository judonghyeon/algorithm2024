#로무토 분할(Lomuto partition) 방식은 퀵 정렬에서 사용되는 또 다른 분할 방법이다.
#이 방식은 마지막 요소를 피벗으로 사용하고, 배열을 피벗보다 작은 요소는 피벗의 앞으로, 큰 요소는 피벗의 뒤로 정렬한디.

def partition(A, left, right):
    pivot = A[right]  # pivot을 배열의 마지막 원소로 선택
    i = left - 1  # i는 pivot보다 작은 원소들의 마지막 인덱스를 추적
    for j in range(left, right):  # right는 pivot이므로 제외
        if A[j] <= pivot:  # 현재 원소가 pivot보다 작거나 같으면
            i += 1  # i를 하나 증가시키고
            A[i], A[j] = A[j], A[i]  # 현재 원소를 A[i]와 교환
    A[i+1], A[right] = A[right], A[i+1]  # pivot을 최종 위치로 옮김
    return i + 1  # pivot의 최종 위치 반환


def quick_select(A, left, right, k):
    pos = partition(A, left, right)
    if(pos+1 ==left+k):
        return A[pos]
    elif (pos+1 > left+k):
        return quick_select(A, left, pos-1, k)
    else:
        return quick_select(A, pos+1, right, k-(pos+1-left))
    

def kth_smallest_sort(A, k):
    A.sort()
    return A[k-1]

array = [12,3,5,7,4,19,23,15]
A = [4, 7, 2, 5, 1]
print("입력 리스트 =", array)
print("[정렬기법] 3번째 작은 수:", kth_smallest_sort(array, 3))
print("[정렬기법] 6번째 작은 수:", kth_smallest_sort(array, 6))
n = len(array)
print("[축소정복] 3번째 작은 수:", quick_select(array, 0, n-1, 3))
print("[축소정복] 6번째 작은 수:", quick_select(array, 0, n-1, 6))

print("Before partition:", A)
pivot_index = partition(A, 0, len(A)-1)
print("After partition:", A)
print("Pivot's final position:", pivot_index)